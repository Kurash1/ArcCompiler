using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;

namespace Eu4ArcCompiler
{
    class Program
    {
        static void Main(string[] args)
        {
            try {
                Arc2 arcs = new Arc2();
                arcs.Main(Environment.GetCommandLineArgs()[1], Environment.GetCommandLineArgs()[0]);
                Console.WriteLine("Press Any Key to exit");
                Console.ReadKey();
            }
            catch (IOException)
            {
                Console.WriteLine("Press Any Key to exit");
                Console.ReadKey();
            }
        }
    }
    public class Scope
    {
        public string Name { get; set; }

        public Scope(string name)
        {
            Name = name;
        }
    }
    public class Arc2
    {
        string dir;
        string[] defines;
        string[] provLoc;

        string[] eventFile = { "#Generated by Arc Eu4 script Compiler | Created by @Kurashi ", "" };
        string[] locFile = { "#Generated by Arc Eu4 script Compiler | Created by @Kurashi ", "1_english:" };
        string[] compileFile;
        string NameSpace = "";
        int EventNum = 0;
        int OptionNum = 0;
        List<Scope> CurrentScope = new List<Scope>();
        string[] arc;
        public void AddScope(string name)
        {
            //Array.Resize(ref CurrentScope, CurrentScope.Length + 1);
            //CurrentScope[CurrentScope.Length - 1] = new Scope(name);
            CurrentScope.Add(new Scope(name));
        }
        public string GetScope()
        {
            return CurrentScope[CurrentScope.Count - 1].Name;
        }
        public void ExitScope()
        {
            //Array.Resize(ref CurrentScope, CurrentScope.Length - 1);
            CurrentScope.RemoveAt(CurrentScope.Count - 1);
        }
        public void Main(string path, string program)
        {
            dir = Directory.GetParent(program).FullName;
            defines = File.ReadAllLines(dir + "\\arc.defines");
            provLoc = File.ReadAllLines(dir + "\\" + defines[0].Substring(21));

            arc = File.ReadAllLines(path);
            string atwe = "";
            for (int i = 0; i < arc.Length; i++)
            {
                arc[i] = arc[i].Trim();
                atwe += arc[i] + "\n";
            }

            compileFile = atwe.Split(null);

            //Console.WriteLine("Compile File");
            //for (int i = 0; i < arc.Length; i++)
            //{
            //    Console.WriteLine(arc[i]);
            //}
            //Console.WriteLine(arc.Length);
            //for (int i = 0; i < compileFile.Length; i++)
            //{
            //    Console.WriteLine(compileFile[i]);
            //}
            //Console.WriteLine(compileFile.Length);

            for (int i = 0; i < compileFile.Length; i++)
            {
                switch (compileFile[i])
                {
                    case "namespace": //Namespace
                        Expect(i + 1, "=");
                        NameSpace = compileFile[i + 2];
                        Default(i);
                        break;
                    case "arc_event": // Arc Scopes
                        OptionNum = 0;
                        Expect(i + 1, "=");
                        Expect(i + 2, "{");
                        Expect(i + 3, "type");
                        Expect(i + 4, "=");
                        EventNum++;
                        AddScope("Event");
                        WriteEvent(compileFile[i + 5] + "_event = {");
                        WriteEvent("id = " + NameSpace + "." + EventNum);
                        WriteEvent("name = " + NameSpace + "." + EventNum + ".t");
                        WriteEvent("desc = " + NameSpace + "." + EventNum + ".d");
                        Expect(i + 6, "english");
                        Expect(i + 7, "=");
                        Expect(i + 8, "{");
                        Expect(i + 9, "name");
                        Expect(i + 10, "=");
                        WriteLoc(compileFile[i + 11]);
                        Expect(i + 12, "desc");
                        Expect(i + 13, "=");
                        WriteLoc(compileFile[i + 14]);
                        Expect(i + 15, "}");
                        i += 15;
                        break;
                    case "arc_option":
                        OptionNum++;
                        AddScope("Option");
                        WriteEvent("option");
                        Expect(i + 1, "=");
                        WriteEvent("=");
                        Expect(i + 2, "{");
                        WriteEvent("{");
                        WriteEvent("name = " + NameSpace + "." + EventNum + "." + ((char)(OptionNum + 64)).ToString());
                        Expect(i + 3, "english");
                        Expect(i + 4, "=");
                        Expect(i + 5, "{");
                        Expect(i + 6, "name");
                        Expect(i + 7, "=");
                        WriteLoc(compileFile[i + 8]);
                        Expect(i + 9, "}");
                        i += 9;
                        break;
                    case "if":
                        if (compileFile[i + 1] == "{")
                        {
                            AddScope("If");
                            WriteEvent("if = { limit = {");
                            i += 1;
                        }
                        else
                        {
                            Default(i);
                        }
                        break;
                    case "}":
                        if(GetScope() == "If")
                        {
                            WriteEvent("}");
                            ExitScope();
                        }
                        Default(i);
                        break;
                    case "capital":
                    case "controls":
                    case "is_claim":
                    case "is_core":
                    case "is_state_core":
                    case "is_territorial_core":
                    case "owns":
                    case "owns_core_province":
                    case "owns_or_non_sovereign_subject_of":
                    case "has_discovered":
                    case "owns_or_subject_of":
                    case "continent":
                        if (!compileFile[i+2].All(char.IsDigit)) {
                            WriteEvent(compileFile[i]);
                            WriteEvent(compileFile[i+1]);
                            WriteEvent(ProvIndexOfStringArray(compileFile[i+2]).ToString());
                            i += 2;
                        }
                        else
                        {
                            Default(i);
                        }
                        break;
                    case "was_tag"
                        if (!compileFile[i + 2].All(char.IsDigit))
                        {
                            WriteEvent(compileFile[i]);
                            WriteEvent(compileFile[i + 1]);
                            WriteEvent(CountryIndexOfStringArray(compileFile[i + 2]).ToString());
                            i += 2;
                        }
                        else
                        {
                            Default(i);
                        }
                        break;
                    default:
                        Default(i);
                        break;
                }
            }
            Console.WriteLine(eventFile[0]);
            Console.WriteLine(eventFile[1]);

            for (int i = 0; i < CurrentScope.Count; i++)
            {
                Console.WriteLine(CurrentScope[i].Name);
            }
        }
        int ProvIndexOfStringArray(string s)
        {
            for (int i = 0; i < provLoc.Length; i++)
            {
                if (provLoc[i].Contains(s))
                {
                    return FindIntInLine(provLoc[i]);
                }
            }
            return 0;
        }

        int ProvIndexOfStringArray(string s)
        {
            for (int i = 0; i < provLoc.Length; i++)
            {
                if (provLoc[i].Contains(s))
                {
                    return FindIntInLine(provLoc[i]);
                }
            }
            return 0;
        }
        
        int FindIntInLine(string s)
        {
            string a = "";
            for (int i = 5; i <= provLoc.Length; i++)
            {
                if (char.IsDigit(s[i]))
                {
                    a += s[i];
                }
                else if (s[i] == ':')
                {
                    return int.Parse(a);
                }
                else
                {
                    return -1;
                }
            }
            return 0; 
        }

        void Default(int i)
        {
            WriteEvent(compileFile[i]);
        }

        void WriteEvent(string s)
        {
            eventFile[1] += s + " ";
        }
        void WriteLoc(string s)
        {
            Array.Resize(ref locFile, locFile.Length + 1);
            locFile[locFile.Length - 1] = s;
        }

        void Expect(int Index, string ToExpect, string Error = "")
        {
            if (compileFile[Index] == ToExpect)
            {
                return;
            }
            else
            {
                if (Error == "")
                {
                    Console.WriteLine("Error: Expecting \"" + ToExpect + "\" Line: " + WordToLine(Index));
                }
                else
                {
                    Console.WriteLine(Error);
                }
                throw new IOException();
            }
        }

        int WordToLine(int index)
        {
            int count = 0;
            for(int i = 0; i < arc.Length; i++)
            {
                if (count == index)
                {
                    return i + 1;
                }

                if (arc[i].Contains(compileFile[count]))
                {
                    i -= 1;
                    count += 1;
                }
            }

            return 0;
        }
    }
}
